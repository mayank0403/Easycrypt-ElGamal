So far, we have explored the \textit{functional} core of
\EasyCrypt. Complementary to it, \EasyCrypt also discloses an
\textit{imperative} subset, captured by \textit{modules}.

\EasyCrypt features a module system that provides a structuring
mechanism for describing imperative constructions. Modules are
composed of a \textit{memory} (a set of global variables, here empty)
and a set of procedures. Procedures in the same module may share state; it is
therefore not necessary to explicitly add state to the module
signature. In addition, modules can be parameterised by other modules
(in which case, we often call them \textit{functors}) whose procedures they can
query like oracles.

Modules are mainly used for representing cryptographic games - either
concrete or abstract. It uses a simple \textit{while} language. For
example, the \INDCPA security game can be is
represented as the following concrete module:

\begin{lstlisting}[mathescape,language=easycrypt,xleftmargin=0pt,xrightmargin=0pt,style=easycrypt-default,basicstyle=\scriptsize\ttfamily,morekeywords={}]  
module INDCPA (S: Scheme) (A: Adversary) = {
  proc main() : bool = {
    var b, b', m0, m1, k, m;

    k <@ S.key_gen();
    (m0, m1) <@ A.gen_query();
    b <$\$$ {0,1};
    m <- if b then m1 else m0;
    c <@ S.encrypt(k, m);
    b' <@ A.guess(c);

    return b';
  }
}.
\end{lstlisting}

In this module, the secret key is first generated by accessing the
\ec{key_gen} procedure. Then, the \textit{adversary} selects two
messages \ec{m0} and \ec{m1}. The game proceeds by randomly sampling a
bit that is used to determine which message is going to be
encrypted. Finally, the adversary, will try to determine if the ciphertext
given to it came from an encryption of \ec{m0} or \ec{m1}.

Note that we make use of different assignment syntaxes:
\begin{itemize}
\item \ec{<-} - assignment of an expression
\item \ec{<@} - assignment of the output of a function call
\item \ec{<}$\$$ - random assignment, i.e., a random value will be
  sampled from a probability distribution
\end{itemize}

The \ec{INDCPA} module is parameterized by a module of \textit{type}
\ec{Scheme} and another of \textit{type} \ec{Adversary}.
%
The constituents of a module and their types are reflected in their
\textit{module type}: a module \ec{M} has module type \ec{I} if all procedures declared
in \ec{I} are also defined in \ec{M}, with the same type and parameters. For
instance, the \ec{Scheme} \textit{module type}, intended to capture
the \textit{type} of symmetric encryption schemes, can be defined as
follows

\begin{lstlisting}[mathescape,language=easycrypt,xleftmargin=0pt,xrightmargin=0pt,style=easycrypt-default,basicstyle=\scriptsize\ttfamily,morekeywords={}]  
module type Scheme = {
  module key_gen() : key
  module encrypt(k : key, pt : plaintext) : ciphertext
  module decrypt(k : key, ct : ciphertext) : plaintext
}
\end{lstlisting}

\noindent meaning that a module that follows this interface will be
considered to have \textit{type} \ec{Scheme}.